# Assignment 5

Contributors:
- Andrew Le, [aal034@ucsd.edu](mailto:aal034@ucsd.edu)
- Theo Lee, [thl030@ucsd.edu](mailto:thl030@ucsd.edu)
- Yezhi Wu, [yew020@ucsd.edu](mailto:yew020@ucsd.edu)

Due: Feb 19 2026

---
## Question 1
Consider the following divide and conquer algorithm that claims to return a set of edges that define an MST of a complete undirected graph $G$ with positive edge weights $w(e)$. 

(A complete undirected graph on $n$ vertices is a graph such that there is an edge between each pair of vertices)

**Algorithm Description:** Given an undirected complete graph $G=(V,E)$ where $V=[v_{1},\dots v_{n}]$,
- If $n=1$ then return the empty set of edges.
- Otherwise, split the set of vertices into two sets: $V'=\left[ v_{1},\dots v_{\frac{n}{2}} \right]$ and $V''=\left[ v_{\frac{n}{2}}+1,\dots,v_{n} \right]$. Any way that you split the vertices, the subgraphs will both be complete graphs so split it up based on the names of the vertices:$V=[v_{1},\dots v_{n}]$.
- Create two new graphs $G'=(V',E')$ and $G''=(V'',E'')$ where $E'\subseteq E$ is the set of edges with both endpoints in $V'$ and $E'' \subseteq E$ is the set of edges with both endpoints in $V''$.
- Recursively run the algorithm on $G'$ and $G''$ to get $M'$ and $M''$, respectively.
- Find the lightest edge $e$ among the remaining edges $E'''$ that connect $G'$ to $G''(E'''=E-(E'\cup E''))$.
- Return $M' \cup M'' \cup \{e\}$.

**Solution**:
![HW5Q1](./NoteFeb182026125145.png)

Solution description: 
- Let $G$ be an undirected complete graph where  $V={v_{1},v_{2},v_{3},v_{4}}$. 
- Then split it into 2 graph $G'=\{v_{1},v_{2}\}$ and $G''=\{v_{3},v_{4}\}$, now $E'=\{(v_{1},v_{2})\}$ and $E''=\{(v_{1},v_{2})\}$.
- Then if $E'''=E-(E' \cup E'')$, and we can not guarantee that the existed $E'$ connect $v_{1} \text{ to } v_{2}$ is lightest path for $G$.
- Also, we can not guarantee that the existed $E''$ connect $v_{3} \text{ to } v_{4}$ is lightest path for $G$.
- Now do the recursive for $G'$, then $M'=\{(v_{1},v_{2})\}$.
- Also, do the recursive for $G''$, then $M''=\{(v_{3},v_{4})\}$.
- Now, let $R= (M' \cup M'' \cup e)$, where $e=lighter(E''')$. Then $R$ can not be guaranteed that is the MST for $G$.

---
## Question 2


---
## Question 3

You are given a list of non-negative integers. (0-indexed): (A[0], . . . , A[n − 1]). You know that A[0] = 0 and A[n − 1] > n − 1.

Design a divide and conquer algorithm that returns an index i such that A[i] ≤ i and A[i + 1] > i + 1 and runs in O(log n) time.

**Solution:**

FindIndex(A):

___L = 0

___R = n - 1 <br><br>

___while R > L + 1:

______m = (L + R) / 2

______if A[m] ≤ m:

_________L = m

______else:

_________R = m <br><br>

___if A[L] ≤ L and A[R] > R:

______return L

___else:

______return -1 (algorithm failes to find an index that satisfies the prompt)

**Runtime Analysis:**

This algorithm recurses on an input of half the size with a non-recursive part runtime of O(1). So the runtime is:

$$T(n) = T(n/2) + O(1)$$

By Master Theorem, T(n) = O(log n)

**Correctness:**

WTS: There is always a valid index that satisfies the prompt:

Since A[0] = 0 which means $A[0] \leq 0$, we satisfied half of the prompt. The prompt is not satisifed only when $A[1] \leq 1$. Then again, with A[1], we satisfied half of the prompt, and the prompt is not satisifed only when $A[2] \leq 2$. If somehow the prompt is not satisifed up until A[n-2], then $A[n-2] \leq n - 2$. But since $A[n-1] > n - 1$, the prompt is satisfied. So there is always a valid index that satisfies the prompt. 

Let f(x) = A[x] - x

Consider the loop invariant: After t iterations, $f(L) \leq 0$ and $f(R) > 0$

Base case: L = 0 and R = n - 1

Since $f(0) \leq 0$ and $f(n - 1) > 0$, according to our proof above, base case holds.

Let m = (L + R)/2

Case 1: $A[m] \leq m$ or $f(m) \leq 0$

Then the algorithm sets L = m and R is unchanged, so $f(L) \leq 0$ and $f(R) > 0$

The invariant is preserverd.

Case 2: $A[m] > m$ or $f(m) > 0$

Then the algorithm sets R = m and L is unchanged, so $f(L) \leq 0$ and $f(R) > 0$

The invariant is preserverd.

The loop stops when R = L + 1. By the invariant that is proved above, $f(L) \leq 0$ and $f(R) > 0$, which means A[i] ≤ i and A[i + 1] > i + 1 <br><br>

Therefore, the algorithm does exactly what the prompt wants.

---
## Question 4
**4(a)**. Let $T(n)$ be the runtime of a divide and conquer algorithm on an input of size $n$. The algorithm has 5 recursive calls each of size $n/3$ and the non-recursive part takes $O(n^2)$ time. Use the [[Master Theorem]] to find the best Big-Oh runtime.

$$
T(n) = 5T\left( \frac{n}{3} \right)+O(n^2)
$$
Then, $a=5,b=3,d=2$. Base on the Master Theorem we got, $a=5,b^d=9,a<b^d$. 
$$
\begin{align}
T(n)=&O(n^d) \text{ if } a < b^d \\
T(n)=&O(n^2) \\
\end{align}
$$
**4(b)**. Let $R(n)$ be the runtime of a divide and conquer algorithm on an input of size $n$. The algorithm has 8 recursive calls each of size $\frac{n}{4}$ and the non-recursive part takes $O(n^{1.5})$ time. Find the best Big-Oh runtime.
$$
R(n)=8R\left( \frac{n}{4} \right)+O(n^{1.5})
$$
Then, $a=8,b=4,d=1.5$. Base on the Master Theorem we got $a=b^d$.
$$
\begin{align}
R(n)=&O(n^d \log n) \text{ if } a = b^d\\
R(n)=&O(n^{1.5}\log n)
\end{align}
$$
**4(c)**. Let $S(n)$ be the runtime of a divide and conquer algorithm on an input of size $n$. The algorithm has 2 recursive calls each of size $\sqrt{ n }$ and the non-recursive part takes $O(1)$ time. Find the best Big-Oh runtime. (Hint: make a change of variables: $n=2^t$)
$$
\begin{equation}
\begin{aligned}
S(n)=&2S(\sqrt{ n })+O(1)\\
=&2S(n^{1/2})+O(1)
\end{aligned}
\end{equation}
$$
Let $n=2^t$, therefore $n^{1/2}=(2^{t})^{1/2}=2^{t/2}$, then
$$
S(2^t) = 2S(2^{t/2})+O(1)
$$
Let $T(t)=S(2^t)$, then we got
$$
T(t)=2T\left( \frac{t}{2} \right)+O(1)
$$
Now, $a=2, b=2, d=0$. Based on the Master Theorem we got $a>b^d$
$$
\begin{align*}
T(t)=&O(n^{\log_{b}^{a}}) \text{ if } a > b^d\\
T(t)=&O(n^{\log_{2}^{2}})\\
T(t)=&O(n^1)=O(n)
\end{align*}
$$
