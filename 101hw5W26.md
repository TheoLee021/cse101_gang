# Assignment 5

Contributors:
- Andrew Le, [aal034@ucsd.edu](mailto:aal034@ucsd.edu)
- Theo Lee, [thl030@ucsd.edu](mailto:thl030@ucsd.edu)
- Yezhi Wu, [yew020@ucsd.edu](mailto:yew020@ucsd.edu)

Due: Feb 19 2026

---
## Question 1
Consider the following divide and conquer algorithm that claims to return a set of edges that define an MST of a complete undirected graph $G$ with positive edge weights $w(e)$. 

(A complete undirected graph on $n$ vertices is a graph such that there is an edge between each pair of vertices)

**Algorithm Description:** Given an undirected complete graph $G=(V,E)$ where $V=[v_{1},\dots v_{n}]$,
- If $n=1$ then return the empty set of edges.
- Otherwise, split the set of vertices into two sets: $V'=\left[ v_{1},\dots v_{\frac{n}{2}} \right]$ and $V''=\left[ v_{\frac{n}{2}}+1,\dots,v_{n} \right]$. Any way that you split the vertices, the subgraphs will both be complete graphs so split it up based on the names of the vertices:$V=[v_{1},\dots v_{n}]$.
- Create two new graphs $G'=(V',E')$ and $G''=(V'',E'')$ where $E'\subseteq E$ is the set of edges with both endpoints in $V'$ and $E'' \subseteq E$ is the set of edges with both endpoints in $V''$.
- Recursively run the algorithm on $G'$ and $G''$ to get $M'$ and $M''$, respectively.
- Find the lightest edge $e$ among the remaining edges $E'''$ that connect $G'$ to $G''(E'''=E-(E'\cup E''))$.
- Return $M' \cup M'' \cup \{e\}$.

**Solution**:
![HW5Q1](./NoteFeb182026125145.png)

Solution description: 
- Let $G$ be an undirected complete graph where  $V={v_{1},v_{2},v_{3},v_{4}}$. 
- Then split it into 2 graph $G'=\{v_{1},v_{2}\}$ and $G''=\{v_{3},v_{4}\}$, now $E'=\{(v_{1},v_{2})\}$ and $E''=\{(v_{1},v_{2})\}$.
- Then if $E'''=E-(E' \cup E'')$, and we can not guarantee that the existed $E'$ connect $v_{1} \text{ to } v_{2}$ is lightest path for $G$.
- Also, we can not guarantee that the existed $E''$ connect $v_{3} \text{ to } v_{4}$ is lightest path for $G$.
- Now do the recursive for $G'$, then $M'=\{(v_{1},v_{2})\}$.
- Also, do the recursive for $G''$, then $M''=\{(v_{3},v_{4})\}$.
- Now, let $R= (M' \cup M'' \cup e)$, where $e=lighter(E''')$. Then $R$ can not be guaranteed that is the MST for $G$.

---
## Question 2

Suppose you have a $n\times n$ 2-dimensional array $A[0,\dots,n-1][0,\dots,n-1]$ filled with distinct integers such that $A[i,j]\leq A[i+1,j]$, $A[i,j]\leq A[i,j+1]$. In other words the numbers are increasing in each dimension (the top left corner is the least number and the numbers increase to the right and increase down.) You also have a target integer $x$. You wish to know if $x$ appears somewhere in $A$.

Consider the following algorithm that will return TRUE if $x$ is in $A$ and FALSE otherwise:

- If $A$ is only a $1\times 1$ array, then check to see if $x$ is equal to $A[0,0]$. If so, return TRUE. Else return FALSE.
- Otherwise, let $m=\lfloor n/2\rfloor$ compare $x$ with $A[m,m]$.
- if $x \leq A[m,m]$ then we know that $x$ is not in the lower right quarter of $A$. So recurse on the 3 other quarters. If you find $x$ in any one of them return TRUE, otherwise return FALSE
- if $x > A[m,m]$ then we know that $x$ is not in the upper left quarter of $A$. So recurse on the 3 other quarters. If you find $x$ in any one of them return TRUE, otherwise return FALSE

(a) Calculate the runtime of this algorithm in terms of $n$.

Solution:

The algorithm compares x with A[m,m] in O(1) time, then recurses on 3 of the 4 quarters. Each quarter is an (n/2) × (n/2) subarray. This gives the recurrence:
  $$T(n) = 3T(n/2) + O(1)$$

Applying the Master Theorem with A = 3, B = 2, D = 0:

Since $A = 3 > B^D = 2^0 = 1$, this is the bottom-heavy case.
  $$T(n) = O(n^{\log_2 3})$$

(b) Is this the best we can do? Describe a strategy for the 2-dimensional array problem that will work in $O(n\log(n))$. (only a high level description and runtime analysis is necessary.)

Solution:

O(n log n) Strategy

Since each row of A is sorted in increasing order, we can perform binary search for x on each row independently.

- There are n rows.
- Binary search on a single row of length n takes O(log n) time.
- Total runtime: O(n log n).

If x is found in any row, return TRUE. If x is not found in any row after searching all n rows, return FALSE.

O(n) Strategy (Bonus)

Given the target integer x, start at the top-right corner A[0, n−1]. Maintain indices i = 0, j = n−1.

At each step, compare x with A[i,j] :
- If A[i, j] == x, return TRUE.
- If x < A[i, j], then all entries below A[i, j] in column j are larger than x. So move left: j = j − 1.
- If x > A[i, j], then all entries to the left of A[i, j] in row i are smaller than x. So move down: i = i + 1.
- If i ≥ n or j < 0, return FALSE.

Runtime analysis: Each step either increments i or decrements j. Since i can increase at most n times and j can decrease at most n times, the algorithm terminates in at most 2n steps = O(n).

---
## Question 3

You are given a list of non-negative integers. (0-indexed): (A[0], . . . , A[n − 1]). You know that A[0] = 0 and A[n − 1] > n − 1.

Design a divide and conquer algorithm that returns an index i such that A[i] ≤ i and A[i + 1] > i + 1 and runs in O(log n) time.

**Solution:**

FindIndex(A):

___L = 0

___R = n - 1 <br><br>

___while R > L + 1:

______m = (L + R) / 2

______if A[m] ≤ m:

_________L = m

______else:

_________R = m <br><br>

___if A[L] ≤ L and A[R] > R:

______return L

___else:

______return -1 (algorithm failes to find an index that satisfies the prompt)

**Runtime Analysis:**

This algorithm recurses on an input of half the size with a non-recursive part runtime of O(1). So the runtime is:

$$T(n) = T(n/2) + O(1)$$

By Master Theorem, T(n) = O(log n)

**Correctness:**

WTS: There is always a valid index that satisfies the prompt:

Since A[0] = 0 which means $A[0] \leq 0$, we satisfied half of the prompt. The prompt is not satisifed only when $A[1] \leq 1$. Then again, with A[1], we satisfied half of the prompt, and the prompt is not satisifed only when $A[2] \leq 2$. If somehow the prompt is not satisifed up until A[n-2], then $A[n-2] \leq n - 2$. But since $A[n-1] > n - 1$, the prompt is satisfied. So there is always a valid index that satisfies the prompt. 

Let f(x) = A[x] - x

Consider the loop invariant: After t iterations, $f(L) \leq 0$ and $f(R) > 0$

Base case: L = 0 and R = n - 1

Since $f(0) \leq 0$ and $f(n - 1) > 0$, according to our proof above, base case holds.

Let m = (L + R)/2

Case 1: $A[m] \leq m$ or $f(m) \leq 0$

Then the algorithm sets L = m and R is unchanged, so $f(L) \leq 0$ and $f(R) > 0$

The invariant is preserverd.

Case 2: $A[m] > m$ or $f(m) > 0$

Then the algorithm sets R = m and L is unchanged, so $f(L) \leq 0$ and $f(R) > 0$

The invariant is preserverd.

The loop stops when R = L + 1. By the invariant that is proved above, $f(L) \leq 0$ and $f(R) > 0$, which means A[i] ≤ i and A[i + 1] > i + 1 <br><br>

Therefore, the algorithm does exactly what the prompt wants.

---
## Question 4
**4(a)**. Let $T(n)$ be the runtime of a divide and conquer algorithm on an input of size $n$. The algorithm has 5 recursive calls each of size $n/3$ and the non-recursive part takes $O(n^2)$ time. Use the [[Master Theorem]] to find the best Big-Oh runtime.

$$
T(n) = 5T\left( \frac{n}{3} \right)+O(n^2)
$$
Then, $a=5,b=3,d=2$. Base on the Master Theorem we got, $a=5,b^d=9,a<b^d$. 
$$
\begin{align}
T(n)=&O(n^d) \text{ if } a < b^d \\
T(n)=&O(n^2) \\
\end{align}
$$
**4(b)**. Let $R(n)$ be the runtime of a divide and conquer algorithm on an input of size $n$. The algorithm has 8 recursive calls each of size $\frac{n}{4}$ and the non-recursive part takes $O(n^{1.5})$ time. Find the best Big-Oh runtime.
$$
R(n)=8R\left( \frac{n}{4} \right)+O(n^{1.5})
$$
Then, $a=8,b=4,d=1.5$. Base on the Master Theorem we got $a=b^d$.
$$
\begin{align}
R(n)=&O(n^d \log n) \text{ if } a = b^d\\
R(n)=&O(n^{1.5}\log n)
\end{align}
$$
**4(c)**. Let $S(n)$ be the runtime of a divide and conquer algorithm on an input of size $n$. The algorithm has 2 recursive calls each of size $\sqrt{ n }$ and the non-recursive part takes $O(1)$ time. Find the best Big-Oh runtime. (Hint: make a change of variables: $n=2^t$)
$$
\begin{equation}
\begin{aligned}
S(n)=&2S(\sqrt{ n })+O(1)\\
=&2S(n^{1/2})+O(1)
\end{aligned}
\end{equation}
$$
Let $n=2^t$, therefore $n^{1/2}=(2^{t})^{1/2}=2^{t/2}$, then
$$
S(2^t) = 2S(2^{t/2})+O(1)
$$
Let $T(t)=S(2^t)$, then we got
$$
T(t)=2T\left( \frac{t}{2} \right)+O(1)
$$
Now, $a=2, b=2, d=0$. Based on the Master Theorem we got $a>b^d$
$$
\begin{align*}
T(t)=&O(t^{\log_{b}^{a}}) \text{ if } a > b^d\\
T(t)=&O(t^{\log_{2}^{2}})\\
T(t)=&O(t^1)=O(t)
\end{align*}
$$
Know, $n=2^t$ then $t=log_{2} n$
$$
S(n)=O(\log(n))
$$
